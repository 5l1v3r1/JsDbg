<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <title>Struct Diff</title>
    <script type="text/javascript" src="/jsdbg.js" data-include-dependencies></script>
    <script type="text/javascript">
        function init() {
            document.querySelector(".type").value = window.localStorage.getItem("struct-diff.type");
            document.querySelectorAll(".pointer")[0].value = window.sessionStorage.getItem("struct-diff.pointer0");
            document.querySelectorAll(".pointer")[1].value = window.sessionStorage.getItem("struct-diff.pointer1");
            document.getElementById("recurse").checked = window.sessionStorage.getItem("struct-diff.recurse") === "true" ? true : false;

            if (document.querySelector(".type").value.length > 0) {
                document.querySelector(".pointer").focus();
            } else {
                document.querySelector(".type").focus();
            }

            document.getElementById("diffButton").addEventListener("click", function() {
                var clock = Timer.Start();
                var type = document.querySelector(".type").value;
                var pointer1 = document.querySelectorAll(".pointer")[0].value.trim();
                var pointer2 = document.querySelectorAll(".pointer")[1].value.trim();
                var shouldRecurse = document.getElementById("recurse").checked;

                window.localStorage.setItem("struct-diff.type", type);
                window.sessionStorage.setItem("struct-diff.pointer0", pointer1);
                window.sessionStorage.setItem("struct-diff.pointer1", pointer2);
                window.sessionStorage.setItem("struct-diff.recurse", shouldRecurse);

                if (type.indexOf("!") < 0) {
                    alert("Please enter a type, prefixed by the module.");
                    return;
                }

                try {
                    pointer1 = new PointerMath.Pointer(pointer1);
                    pointer2 = new PointerMath.Pointer(pointer2);
                } catch (ex) {
                    alert("Please enter valid pointer values.");
                    return;
                }

                var module = type.substr(0, type.indexOf("!"));
                var typename = type.substr(type.indexOf("!") + 1);

                var object1 = new DbgObject(module, typename, pointer1);
                var object2 = new DbgObject(module, typename, pointer2);

                var differences = [];

                // get the structure size...
                object1.size()
                    .then(function(structureSize) {
                        // get some byte arrays...
                        return Promise.join([object1.as("char").array(structureSize), object2.as("char").array(structureSize)]);
                    })
                    .then(function(arrays) {
                        clock.Mark("got arrays");
                        var array1 = arrays[0];
                        var array2 = arrays[1];

                        // find the differences
                        array1.forEach(function(v, i) {
                            if (v != array2[i]) {
                                differences.push(i);
                            }
                        });

                        function generateArray(f, count) {
                            var slots = new Array(count);
                            for (var i = 0; i < count; ++i) {
                                slots[i] = f(i);
                            }
                            return slots;
                        }

                        function flattenInto(array, result) {
                            array.forEach(function(item) {
                                if (item.forEach) {
                                    flattenInto(item, result);
                                } else {
                                    result.push(item);
                                }
                            })
                            return result;
                        }

                        function flatten(array) {
                            return flattenInto(array, []);
                        }

                        function fieldToArrayExpansion(field) {
                            return field.value.hasDesc()
                            .then(function (hasDescription) {
                                if (!hasDescription && field.value.isArray()) {
                                    var values = generateArray(field.value.idx.bind(field.value), field.value.arrayLength());
                                    return Promise
                                        .join(values)
                                        .then(function(values) {
                                            return values.map(function(value, i) {
                                                return {
                                                    "name": field.name + "[" + i + "]",
                                                    "offset": field.offset + (parseInt(value.ptr()) - parseInt(field.value.ptr())),
                                                    "value": value,
                                                    "size": field.size / field.value.arrayLength()
                                                };
                                            })
                                        });
                                } else {
                                    return [field];
                                }
                            });
                        }

                        function expandArrays(fields) {
                            return Promise
                                .map(fields, fieldToArrayExpansion)
                                .then(flatten);
                        }

                        // returns a promise to a field array with all sub-structures expanded
                        function recursivelyExpandFieldsHelper(field, offset, prefix) {
                            field.offset += offset;
                            field.name = prefix + (prefix.length > 0 ? "." : "") + field.name;
                            clock.Mark("expanding " + field.name);

                            if (field.value.isPointer()) {
                                return [field];
                            }

                            return field.value.hasDesc()
                            .then(function (hasDescription) {
                                if (hasDescription) {
                                    // If the type has a type description, don't drill in.
                                    return [field];
                                }

                                return field.value.fields()
                                .then(expandArrays)
                                .then(function (fields) {
                                    return Promise.map(fields, function(innerField) { return recursivelyExpandFieldsHelper(innerField, field.offset, field.name); })
                                }, function(error) {
                                    return [field];
                                })
                                .then(function (fields) {
                                    if (fields.length == 0) {
                                        return [field];
                                    } else {
                                        return fields;
                                    }
                                });
                            });
                        }

                        function recursivelyExpandFields(fields) {
                            return Promise
                                .join(fields.map(function(field) { return recursivelyExpandFieldsHelper(field, 0, ""); }))
                                .then(flatten);
                        }

                        // get the fields.
                        if (shouldRecurse) {
                            return object1.fields()
                                .then(expandArrays)
                                .then(recursivelyExpandFields);
                        } else {
                            return object1.fields();
                        }
                    })
                    .then(function (fields) {
                        clock.Mark("got fields");
                        if (differences.length == 0) {
                            return [];
                        }

                        fields.sort(function(a, b) { return a.offset - b.offset; });

                        // Filter to just the fields that might differ.
                        var currentDifferenceIndex = 0;
                        fields = fields.filter(function(f, i) {
                            while (differences[currentDifferenceIndex] < f.offset) {
                                currentDifferenceIndex++;
                            }

                            return differences[currentDifferenceIndex] < f.offset + f.size;
                        });

                        clock.Mark("got possible different fields");

                        // For fields with a bitcount, we want to actually compare the values.
                        return Promise.filter(fields, function(field) {
                            clock.Mark("checking " + field.name + " for bitcount");
                            if (field.value.bitcount > 0) {
                                return Promise.join([object1.f(field.name).val(), object2.f(field.name).val()])
                                    .then(function(vals) {
                                        clock.Mark("filtering bitcount for " + field.name);
                                        return vals[0] != vals[1];
                                    });
                            }
                            return true;
                        });
                    })
                    .then(function(differentFields) {
                        clock.Mark("got different fields");
                        return Promise.map(differentFields, function(field) {
                            clock.Mark("requesting fields of " + field.name);
                            return Promise.join([object1.f(field.name).desc(), object2.f(field.name).desc()])
                                .then(function(values) {
                                    return [field.name, field.value.typeDescription().replace("<", "&lt;").replace(">", "&gt;"), "0x" + field.offset.toString(16), values[0], values[1]];
                                })

                        });
                    })
                    .then(function(html) {
                        clock.Mark("got HTML");
                        html = html.map(function(cells) {
                            return "<td>" + cells.join("</td><td>") + "</td>";
                        });

                        if (html.length > 0) {
                            document.getElementById("results").innerHTML = 
                                "<table><tr><th>Field</th><th>Type</th><th>Offset</th><th>" + object1.ptr() + "</th><th>" + object2.ptr() + "</th></tr>" +
                                "<tr>" + html.join("</tr><tr>") + "</tr></table>";
                        } else {
                            document.getElementById("results").innerHTML = "<h3>No difference!</h3>";
                        }  
                        clock.Mark("done with comparison");
                    })
                    .then(null, function (err) {
                        var errorSpan = document.createElement("span");
                        errorSpan.classList.add("error");
                        errorSpan.textContent = err;
                        document.getElementById("results").innerHTML = "";
                        document.getElementById("results").appendChild(errorSpan);
                    })
            });
        }

        JsDbg.OnPageReady(init);
    </script>
    <style type="text/css">
        .type {
            width:30em;
        }

        table {
            border-collapse:collapse;
        }

        td {
            padding:0.2em 1em;
        }

        tr:nth-of-type(2n) {
            background:#eee;
        }

        #results {
            margin-top:1em;
        }

        .error {
            color:red;
        }
    </style>
</head>
<body>
    <input class="type" type="text" placeholder="Type (e.g. edgehtml!CFancyFormat)" />
    <input class="pointer" type="text" placeholder="Pointer 1" />
    <input class="pointer" type="text" placeholder="Pointer 2" />
    <button id="diffButton">Diff!</button>
    <input id="recurse" type="checkbox" /><label for="recurse">Show nested fields</label>
    <div id="results"></div>
</body>
</html>